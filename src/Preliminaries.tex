%-------------------------------------------------------------------------
% Section: 前情提要
%-------------------------------------------------------------------------
\chapter{Preliminaries}
\label{cha:Preliminaries}
In this chapter, we introduce the background technology for our work. 
Embedded Linux, UIO Driver, AXI Bus, and DMA.


%-------------------------------------------------------------------------
% Section: 嵌入式理你斯
%-------------------------------------------------------------------------

\section{Embedded Linux}
\label{sec:Embedded Linux}

Embedded Linux is a kernel and set of libraries and utilitied designed to run
on an embedded system(for example:router). Figure~\ref{fig:Linux Boot Stage on Target Platform} shows the stages of booting Linux on the target platform. For example, when turns on the FPGA, the board will boot ROM and find the boot mode setting, then load FSBL(First Stage Bootloader), which will load bitstream to initialize the PL side on FPGA. Then the FGPA will load the SSBL(Second Stage Bootloader), here we use u-boot for demonstration. The main purpose of u-boot is to load Linux Kernel, it loads kernel image with \textbf{\emph{devicetree file}} of the target platform. With well prepared file system(e.g ramdiskfs), the OS should run up successfully.
\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.4]{images/linux_boot_stage.jpg}
  \caption[Linux Boot Stage on Target Platform]{Linux Boot Stage on Target Platform}
  \label{fig:Linux Boot Stage on Target Platform}
\end{figure}



\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.5]{images/embedded_linux.jpg}
  \caption[Embedded Linux on FPGA]{Embedded Linux on FPGA}
  \label{fig:Embedded Linux on FPGA}
\end{figure}



\subsection{Device Tree}
\label{subsec:Device Tree}

Device Tree is a mechanism to describe all hardware and devices of a system. In early Linux 
kernel, hardware description is hardcode in kernel file, so porting kernel to different
ARM-CPU based system is painful. To solve this problem, Device Tree is introduced. 
Like x86 based system, we should consider Linux kernel image is a black box, and give the 
hardware informations of system to kernel. \\
%
In FPGA development flow, the whole system almost keeps the same, the only thing that might change 
is our design in PL(Programmable Logic) side. To boot Linux with different PL design, only 
a little modification of devicetree file is needed.     


\subsection{Linux Kernel Driver}
\label{subsec:Linux Kernel Driver} 
\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.5]{images/linux_kernel_driver.jpg}
  \caption[Linux Kernel Driver]{Linux Kernel Driver}
  \label{fig:UIO Driver}
\end{figure}

%-------------------------------------------------------------------------
% Section: UIO driver
%-------------------------------------------------------------------------

\section{UIO}
\label{sec:UIO}
For many types of devices, creating a Linux kernel driver is overkill. All that is really needed 
is some way to handle an interrupt and provide access to the memory space of the device. To address 
this situation, the userspace I/O system (UIO) was designed.Hardware that is ideally suited for an 
UIO driver fulfills all of the following:
%
\begin{itemize}
\item The device has memory that can be mapped.
\item The device can be controlled completely by writing to this memory.
\item The device usually generates interrupts.
\item The device does not fit into one of the standard kernel subsystems.
\end{itemize}
%
Figure~\ref{fig:UIO Driver} shows how the UIO system works, in software-side of FPGA development, we 
only care about the value in the hardware register and when we can get the correct value, so memeory
-mapping to user-spcae application and interrupt handler is realy enough in our design flow.  
%
\begin{figure}[!htb]
  \centering
  \includegraphics[scale=0.5]{images/uio.jpg}
  \caption[The UIO way.]{The UIO way.}
  \label{fig:UIO Driver}
\end{figure}

%-------------------------------------------------------------------------
% Section: AXI Bus
%-------------------------------------------------------------------------
\section{AXI Bus}
\label{sec:AXI Bus}

Advanced eXtensible Interface (AXI) protocol is part of ARM AMBA(Advanced Microcontroller Bus Architecture).
It is a on-chip bus interface that is targeted at high performance, high clock frequency system designs and includes features that make it suitable for high speed sub-micrometer interconnect:
\begin{itemize}
\item separate address/control and data phases
\item support for unaligned data transfers using byte strobes
\item burst based transactions with only start address issued
\item issuing of multiple outstanding addresses with out of order responses
\item easy addition of register stages to provide timing closure.
\end{itemize}

\subsection{AMBA}
\label{subsec:AMBA}

 
\subsection{AXI4}
\label{subsec:AXI4}
AXI4
\begin{itemize}
\item AXI4:
\item AXI4-Lite:
\item AXI4-Stream:
\end{itemize}





%-------------------------------------------------------------------------
% Section: DMA
%-------------------------------------------------------------------------
\section{DMA}
\label{sec:DMA}

DMA(Direct Memory Access) is a feature that allows hardware subsystems to access main system memory independent of CPU. For example, when CPU want to submit a DMA transaction, it needs to give DMA controller where the data is (memory address), and size of the data(data length). After submit, CPU can back to work for other task, once the transaction is done, CPU will receive a interrupt from DMA controller.
 

\subsection{DMA Engine }
\label{subsec:DMA Engine}